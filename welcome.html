<!DOCTYPE html>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/skapi-js@latest/dist/skapi.js"></script>

<script src="service.js"></script>

<dialog id="el_dl_calling">
</dialog>
<dialog id="el_dl_incoming">
</dialog>

<script>
    let call = null;
    let rtcConnection = null;
    let receiver = null;
    let participants = {};
    let cidList = {};
</script>

<main style="width: 700px; margin: auto; max-width: 100%;">
    <section>
        <h1>Login Success</h1>
        <p id="WelcomeMessage"></p>
        <pre style='max-width: 100%; overflow-x: auto;' id="UserInfo"></pre>
        <button onclick="skapi.logout().then(()=>location.href = 'index.html')">Logout</button>
    </section>

    <script>
        /*
            Get user profile and display it on the page.
        */
        skapi.getProfile().then(u => {
            if (u) {
                let welcomeMessage = document.getElementById("WelcomeMessage");
                if (welcomeMessage) {
                    welcomeMessage.innerHTML = `Welcome, ${u.name || u.email || u.user_id}!`;
                }

                let userInfo = document.getElementById("UserInfo");
                if (userInfo) {
                    userInfo.innerHTML = JSON.stringify(u, null, 2);
                }
            }
            return u;
        });
    </script>

    <h1>Connect WebRTC</h1>

    <label>
        <input type="checkbox" id="allow_video" checked> Allow Video
        <br>
        <input type="checkbox" id="allow_audio" checked> Allow Audio
    </label>

    <br><br>

    <table>
        <thead>
            <tr>
                <th>Username</th>
                <th style="text-align: right;">Connection ID</th>
            </tr>
        </thead>
        <style>
            table {
                border-collapse: collapse;
                width: 100%;
            }

            th,
            td {
                padding: 8px;
                text-align: left;
                border-bottom: 1px solid #ddd;
            }

            tr:hover {
                background-color: #f5f5f5;
            }

            th {
                background-color: #4CAF50;
                color: white;
            }

            tr:nth-child(even) {
                background-color: #f2f2f2;
            }

            tr:nth-child(odd) {
                background-color: #ffffff;
            }
        </style>
        <tbody id="RealtimeParticipants">
            <!-- Realtime participants will be displayed here -->
        </tbody>
    </table>

    <br>

    <section style="text-align: center;" id="el_video_call" hidden>
        <video id="local" autoplay muted></video>
        <video id="remote" autoplay></video>

        <style>
            video {
                max-width: 100%;
                width: 320px;
                height: 240px;
                border: solid 1px;
            }
        </style>

        <br>
        <br>

        <form
            onsubmit="event.preventDefault(); rtcConnection.channels.default.send(document.getElementById('el_input_rtcMessage').value); this.reset();">
            <input type="text" id='el_input_rtcMessage' placeholder='Send RTC Message' name="message">
            <input type="submit" value="Send" disabled>
        </form>

        <br>

        <button type="button" onclick="rtcConnection ? rtcConnection.hangup() : null">Disconnect</button>
    </section>

    <h1>Websocket Log</h1>
    <pre id="el_pre_rtcLog"></pre>

    <style>
        pre {
            overflow-x: auto;
        }

        #el_pre_rtcLog {
            height: 200px;
            border: solid 1px;
        }
    </style>

</main>
<script>
    async function getUserInfo(user_id, cid) {
        if (user_id === skapi.user.user_id) {
            // If the user is the current user, return the current user info.
            participants[user_id] = skapi.user;
            return skapi.user;
        }

        if (cidList[cid] && participants[user_id]) {
            // If the user info is already fetched, return it.
            return participants[user_id];
        }
        else {
            let user = participants[user_id];
            if (!user) {
                user = (await skapi.getUsers({ searchFor: 'user_id', value: user_id })).list?.[0];
                participants[user_id] = user;
            }

            let RealtimeParticipants = document.getElementById("RealtimeParticipants");
            let username = `${user.name || user.email || user.user_id}`;

            RealtimeParticipants.innerHTML += /*html*/`
                <tr id="el_tr_participant-${cid}">
                    <td>
                        <strong>${username}</strong>
                    </td>
                    <td style="text-align: right;">
                        ${cid}
                        <button type="button" onclick="callRTC('${cid}').catch(err=>alert(err.message))">Call</button>
                    </td>
                </tr>
            `;
            cidList[cid] = user_id;
        }

        return participants[user_id];
    }

    function RTCCallback(e) {
        let rtcLog = document.getElementById('el_pre_rtcLog'); // RTC Log

        switch (e.type) {
            // RTC Events
            case 'negotiationneeded':
                rtcLog.innerText += `RTC negotiation needed. Sending offer..\n`;
                break;

            case 'track':
                rtcLog.innerText += `Incoming Media Stream...\n`;
                document.getElementById('remote').srcObject = e.streams[0];
                break;

            case 'connectionstatechange':
                let state = e.state;
                rtcLog.innerText += `RTC Connection:${e.type}:${state}\n` + JSON.stringify(e, null, 2) + '\n-\n';
                if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                    setCallUI(false);
                }
                else if (state === 'connecting') {
                    setCallUI(true);
                }
                break;

            // Data Channel Events
            case 'close':
                rtcLog.innerText += `Data Channel:${e.target.label}:${e.type}\n` + JSON.stringify(e, null, 2) + '\n-\n';
                break;
            case 'message':
                rtcLog.innerText += `Data Channel:${e.target.label}:${e.type}\n` + JSON.stringify(e.data, null, 2) + '\n-\n';
                break;
            case 'open':
            case 'bufferedamountlow':
            case 'error':
                rtcLog.innerText += `Data Channel:${e.target.label}:${e.type}\n` + JSON.stringify(e, null, 2) + '\n-\n';
                break;
        }
        // scroll to bottom
        rtcLog.scrollTop = el_pre_rtcLog.scrollHeight;
    }

    async function callRTC(cid) {
        event.preventDefault();

        let params = {
            media: {
                audio: document.getElementById('allow_audio').checked,
                video: document.getElementById('allow_video').checked
            },
            cid,
        };

        call = await skapi.connectRTC(params, RTCCallback);

        document.getElementById('el_dl_calling').innerHTML = /*html*/`
                <p>Calling</p>
                <button onclick="call.hangup()">Hangup</button>
            `;

        document.getElementById('el_dl_calling').showModal();
        rtcConnection = await call.connection;

        if (!rtcConnection) {
            alert('Call rejected.');
        }
        if (rtcConnection.media) {
            document.getElementById('local').srcObject = rtcConnection.media;
        }
    }

    function setCallUI(state) {
        document.getElementById('el_dl_calling').close();
        document.getElementById('el_dl_incoming').close();

        if (state) {
            // Callback executed when the user is connected to the server.
            el_pre_rtcLog.innerText += 'Connected\n';
            el_video_call.hidden = false;
        }
        else {
            el_video_call.hidden = true;
        }
    }

    function realtimeCallback(rt) {
        console.log({ rt });

        let log = rt;
        try {
            log = JSON.stringify(log, null, 2);
        }
        catch (err) {
        }

        el_pre_rtcLog.innerText += rt.type + ':\n' + log + '\n-\n';
        // scroll to bottom
        el_pre_rtcLog.scrollTop = el_pre_rtcLog.scrollHeight;
        console.log({code: rt.code});
        if (rt.type === 'notice') {
            // User joined the group
            let user_id = rt.sender;

            if (['USER_LEFT', 'USER_DISCONNECTED'].includes(rt.code)) {
                // remove the user from the participants list
                console.log('User left:', rt.sender_cid);
                document.getElementById(`el_tr_participant-${rt.sender_cid}`)?.remove();
                delete participants[rt.sender];
                delete cidList[rt.sender_cid];
            }
            else if (rt.code === 'USER_JOINED') {
                // Add the user to the participants list
                getUserInfo(user_id, rt.sender_cid);
            }
        }

        if (rt.type === 'rtc:incoming') {
            receiver = rt;
            let dl_incoming = document.getElementById('el_dl_incoming');
            // Show incoming call dialog
            dl_incoming.innerHTML = /*html*/`
                <p>Incoming call</p>
                <button onclick='
                    receiver.connectRTC({
                        media: {
                            audio: document.getElementById("allow_audio").checked,
                            video: document.getElementById("allow_video").checked
                        }
                    }, RTCCallback)
                        .then(rtc => {
                            console.log(rtc);
                            rtcConnection = rtc;
                            if(rtc.media) {
                                document.getElementById("local").srcObject = rtc.media;
                            }
                        })
                '>Accept</button>

                <button onclick="receiver.hangup();setCallUI(false)">Reject</button>
            `;

            dl_incoming.showModal();
        }

        else if (rt.type === 'rtc:closed') {
            setCallUI(false);
        }
    }

    skapi.connectRealtime(realtimeCallback);

    function getRealtimeUsers(refresh) {
        skapi.getRealtimeUsers({ group: 'RTCCall' }).then(res => {
            res.list = res.list.filter(p => p.user_id !== skapi.user.user_id); // remove current user from the list
            console.log('Group Participant:', res); // [{user_id: 'user_a', cid: 'user_cid'}, ...]
            if (res.list.length) {
                res.list.map(p => getUserInfo(p.user_id, p.cid));
            }
        });
    }

    skapi.joinRealtime({ group: 'RTCCall' }).then(r => {
        console.log('Realtime Group:', r);
        getRealtimeUsers();
    }); // Join a realtime group
</script>